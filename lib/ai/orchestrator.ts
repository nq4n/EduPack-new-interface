import { EditorProject, BuildLessonResult, RouterAnalysis } from "@/lib/scorm/types"
import { generateLessonFromPrompt } from "@/lib/ai/level2-llm"
import { validateProject } from "@/lib/ai/level0-rules"
import { predictDifficulty, recommendTags } from "@/lib/ai/level1-ml"

const DEFAULT_TRACKING = {
  level: "standard" as const,
  pageViews: true,
  quizInteractions: true,
  media: true,
  hints: false,
  externalLinks: false,
  timePerPage: true,
  attempts: true,
}

const DEFAULT_XAPI = {
  lrsEndpoint: "",
  authToken: "",
  activityIdFormat: "iri",
  statementExtensions: "{}",
}

function applyDefaults(partial: Partial<EditorProject>, language: "en" | "ar"): EditorProject {
  return {
    id: partial.id || `proj-${Date.now()}`,
    title: partial.title || "Untitled Project",
    version: "1.0",
    theme: partial.theme || { direction: language === "ar" ? "rtl" : "ltr", styles: {} },
    pages: partial.pages || [],
    tracking: partial.tracking || { ...DEFAULT_TRACKING },
    xapi: partial.xapi || { ...DEFAULT_XAPI },
  }
}

export function analyzeRequest(teacherInput: string): RouterAnalysis {
  const normalized = teacherInput.toLowerCase()
  const likelyArabic = /[\u0600-\u06FF]/.test(teacherInput)
  const language: "en" | "ar" = likelyArabic ? "ar" : "en"

  const audience = normalized.includes("beginner")
    ? "beginner"
    : normalized.includes("advanced")
      ? "advanced"
      : "general"

  const route: RouterAnalysis["route"] = ["level2", "level1", "level0"]

  const notes = likelyArabic
    ? "Detected Arabic characters; routing with RTL defaults."
    : "Defaulted to English content and layouts."

  return {
    language,
    intent: "build_scorm_lesson",
    audience,
    route,
    notes,
  }
}

/**
 * Orchestrates the creation of a lesson package using a multi-level AI approach.
 *
 * @param teacherInput The initial input from the teacher (e.g., a simple prompt).
 * @param languageOverride Optional override for the target language.
 * @returns A full lesson package with supplementary metadata.
 */
export async function buildLessonPackage(
  teacherInput: string,
  languageOverride?: "en" | "ar"
): Promise<BuildLessonResult> {
  console.log(`Orchestrator: Starting lesson build for prompt: "${teacherInput}"`)

  const routing = analyzeRequest(teacherInput)
  const language = languageOverride || routing.language

  console.log("Orchestrator: Router analysis complete.", routing)

  // --- Level 2: Big AI Model ---
  // First, call the LLM to generate the core content and structure of the lesson.
  // This is necessary because we need the content before we can validate or analyze it.
  const generatedProject = await generateLessonFromPrompt(teacherInput, language)

  // Create a complete project structure from the partial data returned by the LLM
  const project: EditorProject = applyDefaults(generatedProject, language)

  console.log("Orchestrator: Lesson content generated by Level 2 AI.", project)

  // --- Level 1: Simple ML Models ---
  // Run predictions and recommendations on the generated content.
  const [predictedDifficulty, recommendedTags] = await Promise.all([
    predictDifficulty(project),
    recommendTags(project),
  ])
  console.log(
    `Orchestrator: Level 1 ML predictions - Difficulty: ${predictedDifficulty}, Tags: ${recommendedTags.join(", ")}`
  )

  // --- Level 0: Rules & Simple Logic ---
  // Now, run validation rules on the generated content so we capture any issues after ML insights.
  const warnings = validateProject(project)
  console.log("Orchestrator: Validation complete. Warnings found:", warnings)

  // --- Final Combination ---
  // Combine all results into a single, structured response.
  const routerSummary = `Routed to ${routing.route.join(" -> ")} for ${routing.intent} in ${language.toUpperCase()} (${routing.audience}). ${routing.notes || ""}`.trim()

  const result: BuildLessonResult = {
    project,
    warnings,
    metadata: {
      predictedDifficulty,
      recommendedTags,
      routerSummary,
      routing,
    },
  }

  console.log("Orchestrator: Build complete.")
  return result
}

// You could add other orchestrator functions here, for example:
// export async function evaluateStudentWriting(submission: string) { ... }
// export async function recommendNextSteps(studentStats: any) { ... }
